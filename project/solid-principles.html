<link rel="stylesheet" href="../style.css" />

<div class="content" id="solid-principles">
  <ul>
    <li>
      SOLID belongs to 5 different types of principles we are using in project
      architecture
    </li>
  </ul>
  <ol>
    <li>
      S: Single Responsibility Principle (SRP)
      <ul>
        <li>A class should have a single responsibility.</li>
        <li>
          It means "Every software module should have only one reason to
          change".
        </li>
        <li>
          This means that every class, in our code should have only one job to
          do.
        </li>
        <li>
          For Eg: If we have 2 requirements like to register the user and send
          email to the user. <br />
          In this case we will have 2 seperate services called UserService and
          EmailService.
          <br />
          Not everything in a single file
        </li>
        <li>
          We are using this principle because, to separate behaviours so that if
          any bugs comes in coz one of our change change, it wonâ€™t affect other
          unrelated behaviours.
        </li>
      </ul>
    </li>
    <li>
      O: Open/Closed Principle
      <ul>
        <li>
          The Open/closed Principle means "A class is open for extension and
          closed for modification".
        </li>
        <li>
          Changing the current behaviour of a Class will affect all the systems
          using that Class.
        </li>
        <li>
          If we want the Class to perform more functions, the approach is to add
          to the functions that already exist NOT change them. (Simply we can
          extend the class)
        </li>
      </ul>
    </li>
    <li>
      L: Liskov Substitution
      <ul>
        <li>Lets say we have a class A and a class B.</li>
        <li>
          if class A is a subtype of class B, we should be able to replace B
          with A without disrupting the behavior of our program.
        </li>
        <li>(implements)</li>
      </ul>
    </li>
    <li>
      I: Interface Segregation
      <ul>
        <li>
          larger interfaces should be split into smaller ones. By doing so, we
          can ensure that implementing classes only need to be concerned about
          the methods that are of interest to them.
        </li>
        <li>Multiple inheritance</li>
      </ul>
    </li>
  </ol>
</div>
